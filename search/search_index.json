{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> <p></p>"},{"location":"#welcome","title":"Welcome!","text":""},{"location":"#learn-computational-thinking-through-bipes-and-rp2040-based-microcontrollers","title":"Learn Computational Thinking Through BIPES and RP2040 Based Microcontrollers","text":"<p> <p></p> <p></p>"},{"location":"bipes/","title":"An Introduction to BIPES","text":"<p>BIPES: A Block-based Integrated Platform for Embedded Systems is an open source and free platform created for programming various microcontrollers including the Raspberry Pi Pico without code.</p> <p>The original application was created by a team led by Rafael Aroca, a professor at the Federal University at S\u00e3o Carlos (UFSCar) in Brazil.  He was kind enough to allow others (including me) to add to the application, expanding the capabilities of the web based application.  </p>"},{"location":"bipes/#why-use-bipes","title":"Why use BIPES?","text":"<p>BIPES hides the complexity of the MicroPython programming language by allowing users to program the Raspberry Pi Pico via an easy to use graphical interface. BIPES has several built in libraries that make adding accessories to your microcontroller simple. The underlying code can be viewed in the console, giving the interested user the ability to learn as they build on coding concepts.</p>"},{"location":"bipes/#working-with-bipes","title":"Working with BIPES","text":"<p>Working with BIPES is easy, since it web based and runs in most browsers.  Nothing is required to download on to your computer.  BIPES can be found here: https://bipes.net.br/pico/ui/ </p> <p></p>"},{"location":"breadboard/","title":"Breadboard","text":"<p>We use standard solderless small breadboards in our labs. The breadboards have holes that are spaced 1/10th of an inch apart which is a standard for most electronics in the US.</p> <p>Our breadboards are usually 1/2 size with 400-ties. They have a central trough and power rails on the left and right edges.</p>"},{"location":"breadboard/#breadboard-regions-and-connections","title":"Breadboard Regions and Connections","text":"<p>Learning how a breadboard works is critical for building our projects. In the figure above you will see that there are two types of regions of the breadboard</p> <ol> <li> <p>The side regions are called the power distribution rails.  They are similar to power lines that reach across our projects.</p> </li> <li> <p>The central region is called the row connector region. In this area the horizontal rows are all connected inside the breadboard. Within any row, columns a, b, c, d and e are all electrically connected. Within any row, columns f, h, i, j, and k are also electrically connected. However, there is a gap between columns e and f called the center gap or component slot that parts are usually placed over. Components like buttons will have their pins straddle the component slot.</p> </li> </ol>"},{"location":"breadboard/#microcontroller-placement-on-breadboard","title":"Microcontroller Placement on Breadboard","text":"<p>For our labs we place the microcontroller board so that pin 1 of the microcontroller is in row 1 of the breadboard as in the image below.</p> <p></p> <p>This means that the GND connections to the microcontroller are always in rows 3, 8, 13 and 18 on both sides of the breadboard. One of the ground pins can be hooked up to the vertical blue power rails on either side of the breadboard.</p>"},{"location":"install/","title":"Installing the Latest Version of MicroPython","text":"<ol> <li> <p>Get the latest firmware release from MicroPython.org</p> <ul> <li>Download the latest stable uf2 file to your computer</li> </ul> </li> <li> <p>Hold down the boot button on the board (white button)</p> <ul> <li> <p>Plug one end of the USB cable into the board and the other end into your computer</p> </li> <li> <p>Release the boot button</p> </li> </ul> </li> <li> <p>The Pico will show up as a new drive (labeled RPI-RP2) available on your computer</p> </li> <li> <p>Copy the downloaded uf2 file onto the RPI-RP2 drive</p> <ul> <li> <p>The Pico will reboot and be ready to use</p> </li> <li> <p>The RPI-RP2 drive will no longer be visable on your computer.</p> </li> </ul> </li> </ol> <p></p> <p>Modified image courtesy of Raspberry Pi</p>"},{"location":"intro/","title":"Who am I?","text":"I am Jim Tannenbaum (he/him/his), a senior principal engineer at United Healthcare.   I support the Optum STEM outreach program, mentoring middle and high school students in:  Internet Safety, Scratch, Python, BIPES, MicroPython, and Bots  You can contact me by sending email to: jet@uhc.com  You can find me on LinkedIn: https://www.linkedin.com/in/jetannenbaum/"},{"location":"parts/","title":"A List of Parts Being Used","text":"<ol> <li>1/2 Size Breadboard</li> <li>Raspberry Pi Pico RP2040 Microcontroller</li> <li>Micro USB Cable</li> <li>330 Ohm Resistor</li> <li>LEDs</li> <li>Micro Button</li> <li>Potentiometer</li> <li>10K Ohm Resistor</li> <li>Photo Resistor</li> <li>Neopixel Display</li> <li>SD1306 Display</li> <li>Joystick</li> <li>Buzzer</li> <li>Assorted Jumper Wires</li> </ol>"},{"location":"parts/#total-cost-25","title":"Total Cost: ~ $25","text":""},{"location":"pico/","title":"The Raspberry Pi Pico","text":"<p>We will be working with the Raspberry Pi Pico.  It is a low-cost, high-performance microcontroller board with flexible digital interfaces. Key features include:</p> <ul> <li> <p>RP2040 microcontroller chip designed by Raspberry Pi in the United Kingdom</p> </li> <li> <p>Dual-core Arm Cortex M0+ processor, flexible clock running up to 133 MHz</p> </li> <li> <p>264kB of SRAM, and 2MB of on-board flash memory</p> </li> <li> <p>USB 1.1 with device and host support</p> </li> <li> <p>Low-power sleep and dormant modes</p> </li> <li> <p>Drag-and-drop programming using mass storage over USB</p> </li> <li> <p>26 multi-function GPIO pins</p> </li> <li> <p>2 SPI, 2 I2C, 2 UART, 3 12-bit ADC, 16 controllable PWM channels</p> </li> <li> <p>Accurate clock and timer on-chip</p> </li> <li> <p>Temperature sensor</p> </li> <li> <p>Accelerated floating-point libraries on-chip</p> </li> <li> <p>8 Programmable I/O (PIO) state machines for custom peripheral support</p> </li> </ul>"},{"location":"program/","title":"Program Basics","text":"<ul> <li>A list of components</li> <li>Using a prototyping board</li> <li>Introducing the Raspberry Pi Pico micro controller</li> <li>Install the MicroPython interpreter</li> <li>What is BIPES, a Block based Integrated Program for Embedded Systems?</li> <li>Demonstration using BIPES:<ul> <li>Demonstate different computational concepts<ul> <li>Variables</li> <li>Loops</li> <li>Conditionals</li> <li>Functions</li> <li>Lists</li> </ul> </li> <li>Connect the Pico to different components</li> </ul> </li> </ul>"},{"location":"labs/adc/","title":"Our Fifth Lab: Using an Analog to Digital Converter (ADC)","text":""},{"location":"labs/adc/#parts-for-this-lab-are-as-follows","title":"Parts for this Lab are as follows:","text":"<ol> <li> <p>We need a single LED and resistor for this lab.  As a reminder for the setup:</p> <p><code>Insert the Anode(+) lead into j20</code></p> <p><code>Insert the Cathode(-) lead into the Ground(-) rail</code></p> <p><code>Insert the resistor leads into j3 and into the Ground(-) rail</code> </p> </li> <li> <p>We will also use a potentiometer (variable resistor).</p> <ul> <li>Insert the pins of the potentiometer into <code>j30, j29, and j28</code></li> <li>Using one of the jumper wires, insert one end to <code>f30</code> and the other end into the <code>j8</code> </li> <li>Take a second jumper wire, insert one end into the <code>g29</code> and the other into <code>j10</code></li> <li>Using a third jumper wire, insert one end into <code>f28</code> and the other end into <code>j6</code></li> </ul> </li> <li> <p>When you are finished, your breadboard should look similar to the image below (Note: your LED and wires may be different colors)</p> </li> </ol> <p></p>"},{"location":"labs/adc/#what-is-analog-to-digital-conversion-adc","title":"What is Analog to Digital Conversion (ADC)?","text":"<p>The microcontroller has the ability to convert an analog voltage (a voltage anywhere between 0 and ADC_REF volts) to a corresponding digital (0 to 65535) reading.  We can then use that potentiometer to vary the input to one of the ADC pins by turning the knob clockwise and counter clockwise.</p> <p>Note the use of the special voltage pins (ADC_REF and AGND): The supply voltage is filtered, since we want to exclude ripples due to the chip\u2019s internal clock.</p> <p>The object of this lab is to have the external LED start out on.  Then, slowly dim the LED using the potentiometer.  Once the LED is off, slowly bring it back to full brightness.  Continue until you stop the program.</p> <ul> <li> <p>Reading from the ADC pin is accomplished by the following block from the Machine In/Out Pins:</p> <p></p> </li> </ul> <p>Challenge</p> <p>Now that we know how to read data from the potentiometer via the built-in analog to digital converter, we want to use that data to vary the brightness of the LED.</p> <p>Remember that the brightness of the LED can be set by changing the duty cycle of the pulse width modulation, just like we did in the previous lab.</p>"},{"location":"labs/alternatingBlink/","title":"Our Second Lab: Using the Output Blocks to Make LEDs Blink","text":""},{"location":"labs/alternatingBlink/#well-need-two-leds-and-a-330-ohm-resistor","title":"We'll need Two LEDs and a 330 Ohm Resistor","text":"<ol> <li> <p>The longer lead on an LED is the Anode(+) lead.  This is the lead that you will connect to the microcontroller. Let's start with two LEDs</p> <p><code>Insert the Anode leads into j20 and j19</code></p> </li> <li> <p>The shorter lead on an LED is called the Cathode(-).  This is the lead that you will connect to the ground rail.</p> <p><code>Insert the Cathode leads into the Ground(-) rail</code></p> </li> <li> <p>We will also use a resistor from one of the ground pins on the microcontroller and connect it to the ground rail.</p> <p><code>Insert the resistor leads into j3 and into the Ground(-) rail</code> </p> </li> <li> <p>When you are finished, your breadboard should look similar to the image below (Note: your LEDs may be different colors)</p> </li> </ol> <p></p>"},{"location":"labs/alternatingBlink/#how-would-you-make-the-leds-blink-in-an-alternating-pattern","title":"How Would You Make the LEDs Blink in an Alternating Pattern?","text":"<p>The object of this lab is to have one of the external LEDs on while the other is off.  Then switch after a half second.  Continue ten times.</p> <ul> <li> <p>We can modify the first program to use two sets of output pin blocks to control the external LEDs.  </p> </li> <li> <p>Hints: </p> <ul> <li>Look at the Raspberry Pi Pico diagram and find the pins connected to <code>J20 and J19</code>.</li> <li>Add a second set of output pin blocks.</li> <li>Change the pin in the output pin block to select the correct pins.</li> <li>Start with one pin on (true) and the other off (false)</li> </ul> </li> </ul> <p></p> <p>Challenge</p> <p>Can you add more LEDs and have one LED on a time?  Ideally, each LED would be on for 1/2 second while the rest were off, then the next LED would turn on, and so on.</p> <p>Here are some ideas:</p> <ul> <li>Use a list block and a variable block to hold the pins (Pin24, Pin22, Pin 21, ...)</li> </ul> <p></p> <ul> <li>Use a loop block to determine which LED to turn on (rename the loop variable to pin for clarity)</li> </ul> <p></p> <ul> <li>Use a function block (let's call it setPins) to turn on one LED while turning the others off</li> </ul> <p></p> <ul> <li>We'll need some logic to determine which pin to leave on while the other pins are turned off.  This will require another loop block and a Logic block</li> </ul> <p></p> <ul> <li>Finally, we'll need to call the function block</li> </ul> <p></p> <ul> <li>Can you put together the pieces?</li> </ul>"},{"location":"labs/buttonPressInterrupt/","title":"Our Third Lab: Reading a Button Press (Interrupt)","text":"<ol> <li> <p>Using the setup from the last lab, we'll use two LEDs and a resistor. As a reminder:</p> <p><code>Insert the Anode (long) leads into j20 and j19</code></p> <p><code>Insert the Cathode (short) leads into the Ground(-) rail</code></p> <p><code>Insert the resistor leads into j3 and into the Ground(-) rail</code> </p> </li> <li> <p>We'll also use a micro button inserted in the bottom of the board.  As a reminder:</p> <ul> <li> <p>The pins of the switch will straddle the channel and be inserted into <code>e28, e30, f28, and f30</code></p> </li> <li> <p>Using one of the jumper wires, insert one end to <code>j5</code> and the other end into the <code>Power(+) rail</code> </p> </li> <li> <p>Take the second jumper wire, insert one end into the <code>Power(+) rail</code> and the other into <code>j28</code></p> </li> <li> <p>Using the third jumper wire, insert one end into <code>a30</code> and the other end into <code>a20</code></p> </li> <li> <p>When you are finished, your breadboard should look similar to the image below (Note: your LEDs and wires may be different colors)</p> </li> </ul> </li> </ol> <p></p>"},{"location":"labs/buttonPressInterrupt/#what-is-an-interrupt-and-why-would-you-use-it","title":"What is an Interrupt and Why Would You Use It?","text":"<ul> <li> <p>Although the polling version is simple, it does take a lot of the processor resources. The button.value() is checked multiple times a second, even though the button might only be pressed once a day.</p> </li> <li> <p>A more efficient strategy is to use an interrupt handler. This is a function that is \u201cregistered\u201d by MicroPython to handle external events such as button pushes.</p> </li> <li> <p>Think of it like this: instead of checking your phone every 10 seconds, waiting for a text from your friend, your phone vibrates to let you know you have a text.</p> </li> </ul>"},{"location":"labs/buttonPressInterrupt/#using-an-interrupt-handler-block","title":"Using an Interrupt Handler Block","text":"<ul> <li> <p>An interrupt handler has two parts:</p> <ul> <li> <p>The first part is finding the External event (Interrupt on Input Pin) Machine In/Out Pins block and moving it to the canvas.</p> <ul> <li> <p>We will continue to use Pin 20 as the Pin for the interrupt</p> </li> <li> <p>Change the Trigger to  IRQ_RISING.  This indicates that the the interrupt will happen when the button is pressed.</p> <p></p> </li> </ul> </li> <li> <p>The second part is determining what should happen when the interrupt is triggered.  As in the previous lab, we want to turn on one led and turn off the other one.</p> <p></p> </li> </ul> </li> </ul>"},{"location":"labs/buttonPressInterrupt/#tying-it-all-together","title":"Tying it all together","text":"<ul> <li> <p>Our solution needs one more piece.  Since the microprocessor is waiting for an interrupt to happen, we'll add a while Loop block with a delay Timing block.  This will ensure that our blocks will continue to execute while they wait for a button press.</p> <p></p> </li> </ul> <p>Challenge</p> <p>Can you add more LEDs, just as you did in the previous lab?</p> <p>Here are some hints:</p> <ul> <li> <p>The pinList block, setPins function block, and setPins function calling block remain the same</p> </li> <li> <p>Replace the polling block with the interrupt block</p> </li> </ul>"},{"location":"labs/buttonPressPoll/","title":"Our Third Lab: Reading a Button Press (Polling)","text":"<ol> <li> <p>Using the setup from the last lab, we'll use two LEDs and a resistor. As a reminder:</p> <p><code>Insert the Anode (long) leads into j20 and j19</code></p> <p><code>Insert the Cathode (short) leads into the Ground(-) rail</code></p> <p><code>Insert the resistor leads into j3 and into the Ground(-) rail</code> </p> </li> <li> <p>Take a micro button and insert it into the bottom of the board.  The pins of the switch will straddle the channel and be inserted into <code>e28, e30, f28, and f30</code></p> </li> <li> <p>Using one of the jumper wires, insert one end to <code>j5</code> and the other end into the <code>Power(+) rail</code> </p> </li> <li> <p>Take the second jumper wire, insert one end into the <code>Power(+) rail</code> and the other into <code>j28</code></p> </li> <li> <p>Using the third jumper wire, insert one end into <code>a30</code> and the other end into <code>a20</code></p> </li> <li> <p>When you are finished, your breadboard should look similar to the image below (Note: your LEDs and wires may be different colors)</p> </li> </ol> <p></p>"},{"location":"labs/buttonPressPoll/#what-does-a-button-press-look-like-to-the-microcontroller","title":"What Does a Button Press Look Like to the Microcontroller?","text":""},{"location":"labs/buttonPressPoll/#how-would-you-read-the-button-to-make-the-leds-blink-in-an-alternating-pattern","title":"How Would You Read the Button to Make the LEDs Blink in an Alternating Pattern?","text":"<p>The object of this lab is to have one of the LEDs on while the other is off.  Then switch after each button press.  Continue until you stop the program.</p> <ul> <li> <p>We need to create the following blocks:</p> <ul> <li> <p>Add a variable for the current led state (set the state to a true Logic block).</p> </li> <li> <p>Have the loop run forever using a while Loop block set to a true Logic block:</p> </li> </ul> <p></p> <ul> <li>Have the microcontroller read a digital input.  To do so, we need to create a Machine In/Out Pins read digital input block for GPIO20, with the default state to be logical false (pulled down):</li> </ul> <p></p> </li> <li> <p>When the button is pressed, logical true will be applied to the input.</p> </li> <li> <p>Test the value with an if Logic block</p> <ul> <li> <p>If the button is pressed, set the output pin blocks:</p> <ul> <li>Set one block to the ledState Variable block</li> <li>Set the other block using the Logical not block followed by the ledState Variable block</li> <li>Update the value of the ledState Variable block to the Logical not block followed by the ledState Variable block </li> <li>Add a delay Timing block to get a clean button press</li> </ul> <p></p> </li> </ul> </li> <li> <p>Finally move the if blocks inside the while Loop block:</p> <p></p> </li> </ul> <p>Challenge</p> <p>Can you add more LEDs, just as you did in the previous lab?</p> <p>Here are some hints:</p> <ul> <li> <p>Create a variable block to hold the number of the pin you want to turn on.</p> </li> <li> <p>Use the in list list get # List block to get a specific pin for the function call.</p> </li> <li> <p>Use the change variable by 1 Variable block each time the button is pressed.</p> </li> <li> <p>Use a remainder Math block to ensure the number of the pin retrieved from the list doesn't exceed the number of pins in the list.</p> </li> </ul>"},{"location":"labs/buzzer/","title":"Our Tenth Lab: Using a Buzzer to Play Music","text":""},{"location":"labs/buzzer/#use-a-piezo-buzzer-or-equivalent","title":"Use a Piezo Buzzer (or equivalent)","text":"<ol> <li>Place the buzzer with the positive pin (marked with a plus sign) in  <code>h30</code></li> <li>The other pin should line up into <code>f28</code></li> <li>Using one of the jumper wires, insert one end to <code>j30</code> and the other end into <code>j20</code></li> <li> <p>Using another jumper wire, insert one end to <code>j28</code> and the other end into <code>a18</code></p> </li> <li> <p>When you are finished, your breadboard should look similar to the image below (Note: your wires may be different colors)</p> </li> </ol> <p></p>"},{"location":"labs/buzzer/#working-with-music","title":"Working With Music","text":"<ul> <li> <p>We'll need to add two music libraries to our microcontroller.  This can be done through the Install rtttl library and Install songs library buttons in the Sounds secion:</p> <p></p> </li> <li> <p>Now you can select a song or play a tone.</p> </li> </ul> <p>Challenge</p> <ul> <li> <p>Play the Muppets Song</p> </li> <li> <p>Followed by a 1200 Hz tone fo 5 seconds</p> </li> </ul>"},{"location":"labs/joystick/","title":"Our Ninth Lab: Using a Joystick to Draw Lines on an OLED Display","text":""},{"location":"labs/joystick/#parts-for-this-lab-are-the-oled-display-and-a-joystick","title":"Parts for this Lab are the OLED display and a Joystick","text":"<ol> <li> <p>Using the setup from the last lab, we'll use the display.  As a reminder:</p> <ul> <li>Insert the display into <code>f25, f26, f27, and f28</code></li> <li>Using one of the jumper wires, insert one end to <code>i25</code> and the other end into <code>i18</code></li> <li>Using another jumper wire, insert one end to <code>j26</code> and the other end into <code>j5</code></li> <li>Using another jumper wire, insert one end to <code>h27</code> and the other end into <code>b2</code></li> <li>Using another jumper wire, insert one end to <code>i28</code> and the other end into <code>a1</code></li> </ul> </li> <li> <p>Using the wires attached to the joystick, connect them as follows:</p> <ul> <li>The wire from GND on the joystick goes to <code>i8</code></li> <li>The wire from +5V on the joystick goes to <code>i6</code></li> <li>The wire from VRX on the joystick goes to <code>i9</code></li> <li>The wire from VRY on the joystick goes to <code>i10</code></li> <li>The wire from SW on the joystick goes to <code>j20</code></li> </ul> </li> <li> <p>When you are finished, your breadboard should look similar to the image below (Note: your wires may be different colors)</p> </li> </ol> <p></p>"},{"location":"labs/joystick/#drawing-lines-with-a-joystick-and-the-oled-display","title":"Drawing Lines With a Joystick and the OLED Display","text":"<ul> <li> <p>We already added the ssd1306 library to the microcontroller.</p> </li> <li> <p>We also took some time to look at the blocks in the Displays OLED Display section.</p> <ul> <li>Did you notice the line block?</li> </ul> </li> <li> <p>We learned how to read the Analog to Digital Converter inputs in Lab 5.  In this case, we are using two of the ADCs.</p> </li> <li> <p>Additionally, we learned to read a button press in Lab 3.  We do not need to use the interrupt method (although we could)</p> </li> </ul> <p>Challenge</p> <ul> <li> <p>Using what you learned in the previous labs, do the following:</p> <ul> <li> <p>Give the user instructions on how to operate the joystick to clear the screen</p> </li> <li> <p>Wait for the user to press the joystick</p> </li> <li> <p>Clear the screen</p> </li> <li> <p>Read the voltages from the joystick </p> </li> <li> <p>Convert the voltages to a screen coordinate (X, Y)</p> </li> <li> <p>Draw a line from the starting position to the new position</p> </li> <li> <p>Continue until the user clears the screen</p> </li> <li> <p>You will need this function to scale the voltage to a position</p> <p></p> </li> </ul> </li> </ul>"},{"location":"labs/neopixel/","title":"Our Seventh Lab: Using a NeoPixel Display","text":""},{"location":"labs/neopixel/#parts-for-this-lab","title":"Parts for this Lab:","text":"<ol> <li> <p>We will use the neopixel display.</p> <ul> <li>Insert the lead from GND of the display into <code>j3</code></li> <li>Insert the lead from VCC of the display into <code>j40</code></li> <li>Insert the lead from IN of the display into <code>a1</code></li> </ul> </li> <li> <p>When you are finished, your breadboard should look similar to the image below (Note: your wires may be different colors)</p> </li> </ol> <p></p>"},{"location":"labs/neopixel/#working-with-the-neopixel-display","title":"Working With the NeoPixel Display","text":"<ul> <li> <p>NeoPixels are Red-Green-Blue LEDs that are designed to makes them easy to control with three wires: GND, +5V and a single serial data line.</p> </li> <li> <p>Controlling NeoPixels is simple using BIPES.  We only need a few blocks to control the display.</p> <ul> <li> <p>First, we'll need the Init NeoPixel block from Displays NeoPixel Led Strip section</p> <p></p> <p>Our NeoPixel display has 8 segments, and we connected it to Pin 1, so make sure to set the Pin and Number of LEDs correctly in the block.</p> </li> <li> <p>Let's set all of the segments red:</p> <ul> <li>We'll need two more blocks from the Displays NeoPixel Led Strip Section (Control NeoPixel and Write NeoPixel)</li> </ul> <p></p> <ul> <li>Now, with a count Loop block, we can set all of the segments</li> </ul> <p></p> </li> </ul> </li> </ul> <p>Challenge</p> <p>Using a variety of colors, set the pixels, one at time to each color such that it appears that the display starts out with a single pixel lit in a color, then two pixels in the same color, etc. until all 8 are lit.  Then start on a second color lighting the first pixel.</p> <p> </p> <p>Colors can be found here:  https://www.rapidtables.com/web/color/RGB_Color.html</p> <p>Once that works, turn the entire set of pixels on with a single color, then move to the next color that you selected.</p>"},{"location":"labs/onboardBlink/","title":"Our First Lab: Making the Onboard LED Blink","text":""},{"location":"labs/onboardBlink/#selecting-the-blocks","title":"Selecting the Blocks","text":"<p>We'll need a few simple blocks to blink the onboard LED.  We'll want to turn on and off the LED using the following blocks:</p> <ul> <li>Loops<ul> <li>repeat 10 times</li> </ul> </li> </ul> <p></p> <ul> <li>Machine<ul> <li>In/Out Pins<ul> <li>set output pin</li> </ul> </li> </ul> </li> </ul> <p></p> <ul> <li>Timing<ul> <li>delay 1 seconds</li> </ul> </li> </ul> <p></p>"},{"location":"labs/onboardBlink/#blocks-on-the-canvas","title":"Blocks on the Canvas","text":"<p>Once the blocks are selected and placed on the canvas, we'll have to change the second set output pin block so that it turns off the led (setting the pin to false).  We'll also add a second delay block, so we have some time between turning off the led and turning it back on.</p> <p></p> <p>We can execute our blocks by clicking on the angle in the circle next to the microcontroller </p> <p></p> <p></p>"},{"location":"labs/onboardBlink/#adding-a-variable","title":"Adding a variable","text":"<p>Next, we can add a variable block, so we can easily change the delay timing.  We add a single variable and use it in both delay blocks.</p> <ul> <li>Variables<ul> <li>Create variable...</li> </ul> </li> </ul> <p></p> <ul> <li>Click on Create variable... to create a variable and click ok</li> </ul> <p></p> <ul> <li>Now the delay variable blocks are available for use on the canvas.</li> </ul> <p></p> <ul> <li>Drag the set delay block onto the canvas and place it above the loop block</li> </ul> <p></p> <ul> <li>We'll need to set the delay to a number by using a Math number block</li> </ul> <p></p> <ul> <li>Drag the number block to the delay block and set it to 0.5</li> </ul> <p></p> <ul> <li>Now we can get our delay block from the Variables area and insert it into our delay blocks on the canvas.</li> </ul> <p> </p> <p>Challenge</p> <p>What is the fastest you can make the LED blink and still see it changing?  What does this tell you about the human eye?</p>"},{"location":"labs/photoResistor/","title":"Our Sixth Lab: Using a Photo Resistor","text":""},{"location":"labs/photoResistor/#parts-for-this-lab-are-as-follows","title":"Parts for this Lab are as follows:","text":"<ol> <li> <p>We need a single LED and resistor for this lab.  As a reminder for the setup:</p> <p><code>Insert the Anode(+) lead into j20</code></p> <p><code>Insert the Cathode(-) lead into the Ground(-) rail</code></p> <p><code>Insert the resistor leads into j3 and into the Ground(-) rail</code> </p> </li> <li> <p>We will also use a resistor and a photo resistor.</p> <ul> <li>Insert the pins of the resistor into <code>j6 and j10</code></li> <li>Insert the pins of the photo resistor into <code>j8 and i10</code> </li> </ul> </li> <li> <p>When you are finished, your breadboard should look similar to the image below (Note: your LED and wires may be different colors)</p> </li> </ol> <p></p>"},{"location":"labs/photoResistor/#building-a-night-light-with-a-photo-resistor","title":"Building a Night Light With a Photo Resistor","text":"<ul> <li> <p>A photoresistor is a sensor that decreases resistance when light is shined on its surface. With no light a photoresistor has high resistance in the range of megaohms. As light shines on the surface the resistance drops to kiloohms. We can use this effect as a light sensor.</p> </li> <li> <p>To convert the variable resistance of a photoresistor to something we can measure with our microcontroller we will need to build a small circuit that includes a 10K ohm resistor. We then measure the voltage between the photoresistor and the 10K resistor as light falls on the sensor. The top and bottom of the circuit are tied to analog ground (AGND) and reference power(ADC_REF). This will move the voltage of the midpoint of the circuit.</p> </li> <li> <p>From our previous lab, we know that the microcontroller has the ability to convert an analog voltage (a voltage anywhere between 0 and ADC_REF volts) to a corresponding digital (0 to 65535) reading.  We can then use that reading to determine when to turn the LED on or off </p> </li> </ul> <p>Challenge</p> <p>Use the readings from the analog to digital converter pin to determine when to turn the LED on and off.</p> <p>Hints: </p> <ul> <li>You'll need to test the reading from the ADC block with an if else Logic block.  You can start with an if Logic block, then add the else by clicking on the gear and draging the else section over as follows:</li> </ul> <p></p> <ul> <li>If the ADC reading is over the mid-point of an ADC reading, turn the LED on, else turn it off</li> </ul> <p>You may need a bright overhead light to see a change in resistance as you cover and uncover the photo resistor.</p>"},{"location":"labs/pwm/","title":"Our Fourth Lab: Using Pulse Width Modulation (PWM) to Dim an LED","text":""},{"location":"labs/pwm/#parts-for-this-lab","title":"Parts for this Lab:","text":"<ol> <li> <p>We only need a single LED for this lab.  As a reminder for the setup:</p> <p><code>Insert the Anode(+) lead into j20</code></p> <p><code>Insert the Cathode(-) lead into the Ground(-) rail</code></p> <p><code>Insert the resistor leads into j3 and into the Ground(-) rail</code> </p> </li> <li> <p>When you are finished, your breadboard should look similar to the image below (Note: your LED may be a different color)</p> </li> </ol> <p></p>"},{"location":"labs/pwm/#what-is-pulse-width-modulation-pwm","title":"What is Pulse Width Modulation (PWM)?","text":"<p>The object of this lab is to have the external LED start out on.  Then, slowly dim the LED.  Once the LED is off, slowly bring it back to full brightness.  Continue until you stop the program.</p> <p></p> <ul> <li>We used a switch in the previous labs to turn an LED on and off, but what if we wanted to dim the LED?  Since we can\u2019t control the voltage through the output pin blocks of our device, we have to use PWM.  PWM means that we will quickly vary the amount of time (duty cycle) that the voltage is applied to the LED.</li> </ul> <p></p>"},{"location":"labs/pwm/#pwm-how-does-it-work","title":"PWM - How Does It Work?","text":"<ul> <li> <p>PWM is controlled by two factors:</p> <ul> <li>How fast does the power turn on and off (frequency)</li> <li>How long is the power on, relative to the power being off (duty cycle)</li> </ul> </li> <li> <p>We can declare that an output pin block is used as a PWM output pin block using the following block from Machine In/Out Pins:</p> <p></p> </li> <li> <p>This block will set the frequency such that it applies power 1000 times/second (to fast to see) and the duty cycle such that the power is on 50% of the time.  The duty cycle has a range of 0 to 65536.</p> </li> <li> <p>Now that we understand PWM, we can create a set of blocks that starts with the LED off, slowly brings the LED to full brightness, and then slowly back to off.</p> <p></p> </li> </ul> <p>Challenge</p> <p>Once that works, what happens if we repeat the exercise, starting with a frequency of 1000, and reduce the frequency to 10?  Use a list block with values: 1000, 500, 100, 50, 40, 30, 20, &amp; 10. </p> <p>WARNING: Flashing lights!</p>"},{"location":"labs/ssd1306/","title":"Our Eigth Lab: Using an OLED Digital Display","text":""},{"location":"labs/ssd1306/#we-will-use-the-ssd1306-oled-display-in-this-lab","title":"We will use the SSD1306 OLED display in this lab.","text":"<ol> <li> <p>Insert the display into <code>f25, f26, f27, and f28</code></p> </li> <li> <p>Using one of the jumper wires, insert one end to <code>i25</code> and the other end into <code>i18</code></p> </li> <li> <p>Using another jumper wire, insert one end to <code>j26</code> and the other end into <code>j5</code></p> </li> <li> <p>Using another jumper wire, insert one end to <code>h27</code> and the other end into <code>b2</code></p> </li> <li> <p>Using another jumper wire, insert one end to <code>i28</code> and the other end into <code>a1</code></p> </li> <li> <p>When you are finished, your breadboard should look similar to the image below (Note: your wires may be different colors)</p> </li> </ol> <p></p>"},{"location":"labs/ssd1306/#working-with-the-ssd1306-display","title":"Working With the SSD1306 Display","text":"<ul> <li> <p>We'll need to add the SSD1306 Library to our microcontroller.  This can be done through the Install ssd1306 library button in the Display OLED Display section:</p> <p></p> </li> <li> <p>Our display uses an Inter-Integrated Circuit (I2C) interface.  The I2C interface was first developed by Phillips Semiconductor in 1982 to facilitate serial communication between devices.</p> </li> <li> <p>Initialize the display with the Init I2C SSDD1306 OLED Display block, taking care to set I2C to 0, SCL to Pin 2, and SDA to Pin 1.</p> <p></p> </li> <li> <p>Now we can write \"Hello\" to the display with the Write text on display block</p> <p></p> </li> </ul> <p>Challenge</p> <ul> <li> <p>Start by writing your name to the display at the top left corner (0, 0).</p> </li> <li> <p>Pause for 1 second</p> </li> <li> <p>Clear the screen (use the Clear OLED Display block)</p> </li> <li> <p>Move your name down and to the right</p> </li> <li> <p>Pause again</p> </li> <li> <p>Continue moving down and to the right until you get to the bottom or the right edge of the screen. </p> </li> </ul>"},{"location":"solutions/lab10/","title":"Our Tenth Lab: Using a Buzzer to Play Music","text":""},{"location":"solutions/lab10/#solution-playing-the-muppets-song-and-a-1200-hz-tone-for-5-seconds","title":"Solution: Playing the Muppets Song and a 1200 Hz Tone for 5 Seconds","text":"<p>You may have to listen carefully to hear the music and the tone.</p>"},{"location":"solutions/lab2/","title":"Our Second Lab: Using the Output Blocks to Make LEDs Blink","text":""},{"location":"solutions/lab2/#solution-blinking-three-or-more-leds","title":"Solution: Blinking Three (or More) LEDs","text":""},{"location":"solutions/lab3i/","title":"Our Third Lab: Reading a Button Press (Interrupt)","text":""},{"location":"solutions/lab3i/#solution-sequencing-through-three-or-more-leds","title":"Solution: Sequencing Through Three (or More) LEDs","text":""},{"location":"solutions/lab3p/","title":"Our Third Lab: Reading a Button Press (Polling)","text":""},{"location":"solutions/lab3p/#solution-sequencing-through-three-or-more-leds","title":"Solution: Sequencing Through Three (or More) LEDs","text":""},{"location":"solutions/lab4/","title":"Our Fourth Lab: Using Pulse Width Modulation (PWM) to Dim an LED","text":""},{"location":"solutions/lab4/#solution-changing-the-frequency-and-duty-cycle","title":"Solution: Changing the Frequency and Duty Cycle","text":""},{"location":"solutions/lab5/","title":"Our Fifth Lab: Using an Analog to Digital Converter (ADC)","text":""},{"location":"solutions/lab5/#solution-changing-the-duty-cycle-with-a-potentiometer","title":"Solution: Changing the Duty Cycle With a Potentiometer","text":""},{"location":"solutions/lab6/","title":"Our Sixth Lab: Using a Photo Resistor","text":""},{"location":"solutions/lab6/#solution-creating-a-night-light","title":"Solution: Creating a Night Light","text":""},{"location":"solutions/lab7/","title":"Our Seventh Lab: Using a NeoPixel Display","text":""},{"location":"solutions/lab7/#solution-1-setting-colors-one-at-a-time","title":"Solution 1: Setting colors one at a time","text":""},{"location":"solutions/lab7/#solution-2-setting-colors-at-the-same-time","title":"Solution 2: Setting colors at the same time","text":"<p>Did you notice the subtle difference between the solutions?  </p> <ul> <li> <p>In the first solution, we used the Write NeoPixel block each time a segment was set in the Control NeoPixel block.  </p> </li> <li> <p>In the second solution, we used the Write NeoPixel block only after all the segments were set in the Control NeoPixel block.</p> </li> </ul>"},{"location":"solutions/lab8/","title":"Our Eigth Lab: Using an OLED Digital Display","text":""},{"location":"solutions/lab8/#solution-moving-text-around-the-display","title":"Solution: Moving Text Around the Display","text":""},{"location":"solutions/lab9/","title":"Our Ninth Lab: Using a Joystick to Draw Lines on an OLED Display","text":""},{"location":"solutions/lab9/#solution-drawing-lines-on-the-display","title":"Solution: Drawing Lines on the Display","text":""}]}